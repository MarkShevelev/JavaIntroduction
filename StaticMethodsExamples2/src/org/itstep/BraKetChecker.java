package org.itstep;

import java.util.Scanner;

public class BraKetChecker {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Введите строку: ");
        String userString = sc.nextLine();

        boolean isGood;
        isGood = noMethodsChecker(userString);
        //isGood = delegatingChecker(userString);

        System.out.println( isGood ? "Верная скобочная конструкция" : "Неверная скобочная конструкция" );
    }

    /**
     * Программа проверяет правильность скобочной конструкции, не используя отдельных методов, всё в одном...
     *
     * @param inputString строка для проверки скобок
     * @return            возвращает true, если скобочная конструкция верна, иначе - false
     * */
    public static boolean noMethodsChecker(String inputString) {
        //pile - это стопка, куда мы будем складывать все встречающиеся нам открывающиеся скобки,
        //что позволит нам не выполнять повторные проходы по строке в поисках предыдущей открывающейся скобки,
        //но возможность просто взять последнюю положенную в стопку
        //P.S. Такая стопка, из которой мы берём последний положенный элемент называется "Stack"
        char[] pile = new char[inputString.length()];
        int pileTop = 0; //индекс элемента массива pile (стопки), в который сейчас можно положить следующую скобку
        char[] braArr = {'(','[','{','<'}; //набор всех возможных открывающихся скобок
        boolean isGood = true; //флаг, указывающий верность скобочной конструкции; изначально предполагаем, что конструкция верна

        //основной цикл обхода строки
        string_loop: //метка цикла //зачем? смотри ниже
        for (char c : inputString.toCharArray()) { //.toCharArray() позволяет нам взять у строки ссылку на массив её символов
            //сначала необходимо проверить текущий символ на совпадение с открывающийся скобкой
            for (char bra : braArr)
                if (c == bra) {
                    pile[pileTop++] = c;
                    //если совпадение найдено, то дальнейший поиск не имеет смысла
                    //более того, нет необходимости выполнять какие-либо действия далее по итерации основного цикла,
                    //необходимо перейти на следующую итерации основного цикла обхода строки
                    //т.к. continue; пропускает итерацию ближайшего цикла, а ближайший - это цикл поиска,
                    //то применяем метку к основному циклу
                    continue string_loop;
                }

            //если мы добрались до этой точки, то символ точно не является открывающейся скобкой
            //будем проверять на закрывающуюся

            //сначала получим символ последней открывающий скобки, символ '#' используем для пустой стопки, он точно не убирает никакую скобку
            char lastBra = 0 == pileTop ? '#' : pile[pileTop-1]; //Внимание! нужно проверить pileTop на ноль!
            switch(c) { //Для каждой из закрывающихся скобок пытаемся проверить верность открывающеся
                case ')':
                    if ('(' == lastBra) { --pileTop; continue string_loop; } //если совпадение найдено, то понижаем кол-во
                                                                             //элементов в стопке и переходим к следующему символу
                    //если проверка провалена, устанавливаем флаг в false и выходим из цикла
                    isGood = false;
                    break string_loop; //break; выведет нас из switch, потому применяем метку, чтобы покинуть сразу основной цикл

                case ']':
                    if ('[' == lastBra) { --pileTop; continue string_loop; }
                    isGood = false;
                    break string_loop;

                case '}':
                    if ('{' == lastBra) { --pileTop; continue string_loop; }
                    isGood = false;
                    break string_loop;

                case '>':
                    if ('<' == lastBra) { --pileTop; continue string_loop; }
                    isGood = false;
                    break string_loop;
            }

            //если мы добрались до этой строки, значит символ является чем угодно, только не скобкой
            //такой символ не требует от нас никакой обработки
        }

        //когда цикл завершился есть несколько вариантов
        //i)   isGood содержит false - это произойдёт, если мы встретили неверную пару или одинокую закрывающую скобку
        //ii)  isGood содержит true, но pileTop не равно 0 - это означает, что все закрывающие скобки имеют пару, но отрывающие могут пары не иметь
        //iii) isGood содержит true и pileTop равен 0 - верная скобочная конструкция!
        //Т.е. результат состоит из двух условий
        return isGood && 0 == pileTop;
    }

    /**
     * Программа выполняет только необходимые действия: управляет потоком условий
     * Короткие действия по поиску совпадений и т.е. "делегируются" другим методам
     * Это повышает читаемость кода и позволяет при необходимости тестировать короткие методы отдельно
     * */
    public static boolean delegatingChecker(String inputString) {
        //стопка открывающих скобок
        char[] pile = new char[inputString.length()];
        int pileTop = 0; //индекс элемента массива pile (стопки), в который сейчас можно положить следующую скобку
        //два набора скобок, устроенные специальным образом: парные скобки имеют одинаковые индексы
        char[] braArr = {'(','[','{','<'}; //набор всех возможных открывающихся скобок
        char[] ketArr = {')',']','}','>'}; //набор всех возможных закрывающих скобок
        boolean isGood = true; //флаг, указывающий верность скобочной конструкции; изначально предполагаем, что конструкция верна

        //основной цикл обхода строки
        for (char c : inputString.toCharArray()) {
            if ( inArray(braArr,c) ) { //описанный ниже метод inArray проверяет наличие указанного элемента c в массиве bra
                pile[pileTop++] = c;
                continue; //нет необходимости в метке, т.к. нет вложенности циклов
            }

            if ( inArray(ketArr,c) ) { //если символ скобка, то проверим соответствие, иначе ничего не делаем
                char lastBra = 0 == pileTop ? '#' : pile[pileTop - 1];
                if ( !rightBraKet(braArr,ketArr,lastBra,c) ) { //метод описан ниже
                    isGood = false;
                    break; //не требуется метка, т.к. нет switch или цикла, вложенного в основной
                }
                //если всё хорошо, сдвигаем pileTop назад на один элемент, т.к. последняя скобка "взаимоуничтожилась" с текущим символом
                --pileTop;
            }

            //если добрались сюда, то символ не является ни открывающейся, ни закрывающейся скобками
            //ничего не делаем в этом случае
        }

        return isGood && 0 == pileTop;
    }

    /**
     * Метод проверяет будут ли скобки парными
     * Задача сводится к тому, что индексы двух элементов bra и ket в массивах braArr и ketArr, соответственно, должны совпасть
     *
     * @param braArr массив открывающих скобок
     * @param ketArr массив закрывающих скобок
     * @param bra    открывающая скобка, индекс которой ищем в первом массиве braArr
     * @param ket    закрывающая скобка, индекс которой ищем во втором массиве ketArr
     * @return       true - если индексы совпали, иначе - false
     * */
    private static boolean rightBraKet(char[] braArr, char[] ketArr, char bra, char ket) {
        int braPos, ketPos;
        //bra
        for (braPos = 0; braPos != braArr.length; ++braPos)
            if (bra == braArr[braPos]) break;

        for(ketPos = 0; ketPos != ketArr.length; ++ketPos)
             if (ket == ketArr[ketPos]) break;

        return braPos == ketPos;
    }

    /**
     * Простой метод, проверяющуй содержится ли указанный символ в переданном массиве
     *
     * @param arr массив, в котором производится поиск
     * @param toFind символ, который ищем в массиве
     * */
    private static boolean inArray(char[] arr, char toFind) {
        for (char c : arr)
            if (c == toFind) return true;
        return false;
    }
}
