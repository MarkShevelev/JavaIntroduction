package org.itstep;

public class PrimitiveTypesConversions {
    public static void main(String[] args) {
        /**
         * Примитивные типы данных могут явно и неявно преобразовываться в ходе вычислений, включая присваивание
         * */

        //неявные преобразования при присваивании
        if (false) {
            byte b = 1;
            short sh = b; //присваивание с неявным преобразованием, т.к. любое значение byte можно положить в short
            //b = sh; //ошибка компиляции!
            //Неявное преобразование невозможно, т.к. short может содержать значение, которое нельзя пложить в byte

            int i = sh;  //неявное преобразование, т.к. любое значение short можно положить в int
            //sh = i; b = i; //оба присваивания вызывают ошибку, т.к. int содержит больший, чем byte и short диапазон значений
            long lg = i; //неявное преобразование, т.к. любое значение int можно положить в long
            //i = lg; sh = lg; b = lg; //присваивания вызывают ошибки компиляции

            float f = lg; //неявное преобразование из long в float, хотя возможна потеря точности, язык Java допускает такое преобразование
            //lg = f; //обратное вызовет ошибку
            //i = f; sh = f; b = f; //как и преобразования float в любой другой целочисленный тип
            double d = f; //неявное преобразование без потери точности, любой float представим как double
            //f = d; lg = d; i = d; b = d; //все преобразования вызывают ошибку компиляции

            //Неявные преобразования происходят в сторону повышения диапазона значений
            //byte -> short -> int -> long -> float -> double
        }

        //явные преобразования при присваивании
        if (false) {
            int i = 1;
            byte b;
            //b = i;//компилятор не даёт выполнить операцию
            //хотя мы понимаем, что 1 можно положить в тип byte без проблем, компилятор не пытается "угадать" наши действия
            //необходимо явно сообщить компилятору, что мы уверены в правильности принятого решения
            b = (byte)i; //имя типа, взятое в круглые скобки, перед переменной i показывает компилятору,
            //что мы намеренно производим присваивание

            long lg = 345L;
            //int i2 = lg; //ошибка компиляции
            int i2 = (int)lg; //явное преобразование - сообщаем компилятору, что мы уверены в том, что делаем

            //при явном преобразовании чисел float и double дробная часть отбрасывается
            float f1 = 0.2f;
            double d1 = 0.999;
            int i3 = (int)f1; //в i3 попадёт 0
            int i4 = (int)d1; //и в i4 попадёт 0

            //double можно float явно преобразовать во float, однако, скорее всего, преобразование приведёт к серьёзной потере точности
            float f2 = (float)d1;
        }

        //тип char
        if (false) {
            char ch = 'Ё';
            //byte b = ch; //нельзя неявно преобразовать char в byte
            //short sh = ch; //нельзя неявно преобразовать char в short
            int i = ch; //а вот в int можно!
        }

        //неявные преобразования при вычислениях
        if (false) {
            byte b1 = 100, b2 = 27;
            //byte b3 = b1+b2; //выражение не скомпилируется, т.к. несмотря на отсутствие потерь (хотя они могли бы быть)
            //все вычисления на типах byte, short и int производятся в типе (int)
            //оператор + возвращает новый int
            int i1 = b1+b2; //верно!

            //Если мы уверены в том, что проблем с точностью нет, или намеренно использует тип byte
            byte b3 = (byte)(b1+b2);//мы можем явно привести результат к типу int

            //если при вычислении одна из переменных имеет тип long, то все вычисления выполняются в типе long
            long lg1 = 345L;
            int i2 = -345;
            //int res = i2 + lg1; //ошибка компиляции! lg1 имеет тип long, следовательно всё выражение имеет тип long
            //применим явное преобразование
            int res = (int)(i2 + lg1);

            //иногда выгодно выполнить явное преобразование не к меньшему типу, а к большему.
            //следующее выражение выдаст неожиданный результат
            int j1 = 2147483647, j2 = 2147483647;
            long lg2 = j1+j2;
            System.out.println(lg2); //печатает -2
            //Тип переменной, в которую мы сохраняем значение, не важен для компилятора при разборе арифметического вычисления
            //потому нам придётся явно расширить одину из переменных до long, чтобы вычисления производились в типе long
            lg2 = j1+(long)j2;
            System.out.println(lg2); //печатает 4294967294

            //Если один из операндов является числом с плавающей точкой (float или double), то все вычисления производятся в float или double
            long lg3 = 2147483648L;
            float f1 = 2.e9f; //формат записи означает 2 * 1 000 000 000
            //long lg4 = f1+lg3; //хотя в типе long данное вычисление вполне может быть выражено точно,
            //компилятор приводит всю арифметику в тип float
            long lg4 = (long)(f1+lg3);

            //Мы также можем использовать намеренное привидение арифметики к дробному типу (float или double)
            int numerator = 10, denominator = 3;
            System.out.println(numerator/denominator > 3.3); //печатает false
            //деление двух целых чисел приводит к тому, что возвращается только целая часть и результат не позволяет использовать его в неравенстве
            //следует учесть остаток от деления
            //мы можем приблизительно учесть его, используя арифметику с плавающей точкой

            System.out.println(numerator/(float)denominator > 3.3); //печатает true

            //однако наш результат может получиться в ошибочным из-за внутренних округлений типа float
            System.out.println(numerator/(float)denominator > 3.3333333); //печатает false
            System.out.println(numerator/(double)denominator > 3.3333333); //печатает true
            System.out.println(numerator/(double)denominator > 3.33333333333333333); //печатает false
        }
    }
}
